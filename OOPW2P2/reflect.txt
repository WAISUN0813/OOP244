I learnt about function overloading and dynamic memory in OOP244 Workshop 2. Function overloading enables programmers to have many functions with the same name in the same class or namespace, but with different arguments. First, I spent a significant amount of effort figuring out how to control different arguments in the same name function. For example, bool read(char*& name), bool read(int &number), and bool read(double &salary) since the parameters have different types and the programme can tell which read to employ based on the type.
My favourite topic to study is dynamic memory. To avoid memory leaks, dynamic allocation to store memory requires dynamic deallocation. To dynamically allocate, I used postalCode.code = new char[strlen(code) + 1] and postalcode = new PostalCode[noOfPostalCode].  new char[strlen(code) + 1] postalCode.code In postalCode.code, 4 bytes of memory "A0A" plus 1 null terminator can be stored. To store dynamic arrays, postalcode = new PostalCode[noOfPostalCode] is used. We require dynamic deallocation while using dynamic memory. I used delete[] postalcode[i].code to deallocate memory for the postal code; delete[] postalcode to deallocate memory for the postal code array.